№3. Реализовать базовый класс Рабочий (работник),
# в котором определить атрибуты: имя, фамилия, должность (должность), доход (доход).
# Последний атрибут должен быть защищенным и ссылаться на словарь,
# нарушающие элементы: оклад и премия, например, {"wage": wage, "bonus": bonus}.
# Создать класс Position (должность) на базе класса Worker.
# В классе Position реализовать методы получения полного имени сотрудника (get_full_name)
# и доход с учетом бонуса (get_total_income).
# Проверить работу примера на реальных данных
# (создать экземпляры класса Position, передать данные, проверить значения атрибутов, вызвать методы экземпляров).

class  Worker :   # родительский класс
    имя : ул.
    фамилия : ул.
    позиция : ул.
    _income  =  dict ( заработная плата = 'заработная плата' , бонус = 'бонус' )

    def  __init__ ( я , имя , фамилия , должность , заработная плата , премия ):   # конструктор объекта
        я . name  =  имя
        я . surname  =  фамилия
        я . позиция  =  позиция
        я . _income [ "wage" ] =  заработная плата
        я . _income [ "бонус" ] =  бонус


class  Должность ( Рабочий ):   # дочерний класс

    def  get_full_name ( self ):   # метод
        return  f " { self . name }  { self . surname } "

    def  get_total_income ( self ):   # метод
        вернуть  себя . _income [ "заработная плата" ] +  self . _income [ "бонус" ]


position_1  =  Position ( "Пётр" , "Первый" , "Царь" , 1000 , 200 )   # экземпляр класса

print ( f "Имя: { position_1 . name } " )   # вызов метода
print ( f "Фамилия: { position_1 . surname } " )
print ( f "Должность: { position_1 . position } " )
print ( f "Метод get_full_name: { position_1 . get_full_name () } " )
print ( f "Метод get_total_income: { position_1 . get_total_income () } " )
